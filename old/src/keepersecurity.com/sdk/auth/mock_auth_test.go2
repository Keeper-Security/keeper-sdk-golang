package auth

import (
	"bytes"
	"crypto"
	authentication2 "keepersecurity.com/sdk/pkg/authentication"
	"time"

	"github.com/golang/protobuf/proto"
	"keepersecurity.com/sdk/auth/impl"
	"keepersecurity.com/sdk/protobuf/account_summary"
	"keepersecurity.com/sdk/protobuf/authentication"
	"keepersecurity.com/sdk/protobuf/push"
)

func NewMockAuth(emptyStorage bool) (authSync impl.IAuthSync, endpoint *endpointMock) {
	endpoint = newEndpointMock()
	storage := NewInMemoryConfigurationStorage()
	if !emptyStorage {
		storage.SetLastServer(defaultKeeperContext.server)
		storage.SetLastLogin(defaultKeeperContext.username)

		var deviceToken = Base64UrlEncode(defaultKeeperContext.deviceToken)
		var deviceKey, _ = UnloadEcPrivateKey(defaultKeeperContext.devicePrivateKey)
		d := NewDeviceConfiguration(deviceToken, deviceKey)
		ds := NewDeviceServerConfiguration(defaultKeeperContext.server)
		ds.CloneCode_ = Base64UrlEncode(defaultKeeperContext.cloneCode)
		d.ServerInfo().Put(ds)
		storage.Devices().Put(d)
		s := NewServerConfiguration(defaultKeeperContext.server)
		storage.Servers().Put(s)

		u := NewUserConfiguration(defaultKeeperContext.username)
		u.Server_ = defaultKeeperContext.server
		u.LastDevice_ = &UserDeviceConfiguration{
			DeviceToken_: deviceToken,
		}
		storage.Users().Put(u)
	}

	authSync = impl.NewAuthEndpoint(storage, endpoint)
	return
}

// /////////////////////////////////////////////

type authSyncCallback struct {
	callback func()
}

func (c *authSyncCallback) OnNextStep() {
	if c.callback != nil {
		c.callback()
	}
}

type deviceInfo struct {
	publicKey []byte
	Approved  bool
	TwoFactor bool
}
type endpointMock struct {
	server      string
	serverKeyId int32

	onExecuteRest func(string, []byte) ([]byte, error, bool)
	NewDevice     deviceInfo
	push          *PushEndpoint
}

func newEndpointMock() *endpointMock {
	return &endpointMock{}
}
func (em *endpointMock) ClientVersion() string {
	return "mock1.0.0"
}
func (em *endpointMock) SetClientVersion(_ string) {
}
func (em *endpointMock) Server() string {
	if em.server != "" {
		return em.server
	}
	return defaultKeeperContext.server
}
func (em *endpointMock) SetServer(server string) {
	em.server = server
}
func (em *endpointMock) PushServer() string {
	return "push.services." + em.Server()
}
func (em *endpointMock) DeviceName() string {
	return "Keeper Golang SDK Unit Tests"
}
func (em *endpointMock) SetDeviceName(_ string) {
}
func (em *endpointMock) Locale() string {
	return "en_US"
}
func (em *endpointMock) SetLocale(_ string) {
}

func (em *endpointMock) ServerKeyId() int32 {
	return em.serverKeyId
}
func (em *endpointMock) PrepareApiRequest(payload []byte, transmissionKey []byte, sessionToken []byte) (request *authentication.ApiRequest, err error) {
	requestPayload := &authentication.ApiRequestPayload{
		ApiVersion: 3,
		Payload:    payload,
	}
	if sessionToken != nil {
		requestPayload.EncryptedSessionToken = sessionToken
	}

	var rqPayload []byte
	if rqPayload, err = proto.Marshal(requestPayload); err != nil {
		return
	}
	var encPayload []byte
	if encPayload, err = EncryptAesV2(rqPayload, transmissionKey); err != nil {
		return
	}
	request = &authentication.ApiRequest{
		EncryptedTransmissionKey: transmissionKey,
		PublicKeyId:              0,
		Locale:                   em.Locale(),
		EncryptedPayload:         encPayload,
	}
	return
}

func (em *endpointMock) ConnectToPushServer(wssRequest *push.WssConnectionRequest) (push IPushEndpoint, err error) {
	em.push = &PushEndpoint{}
	push = em.push
	return
}

func (pe *endpointMock) ExecuteRest(endpoint string, request []byte, sessionToken []byte) (response []byte, err error) {
	var ok bool
	if pe.onExecuteRest != nil {
		response, err, ok = pe.onExecuteRest(endpoint, request)
		if ok {
			return
		}
	}

	switch endpoint {
	case "authentication/register_device_in_region":
		{
			rq := new(authentication.RegisterDeviceInRegionRequest)
			if err = proto.Unmarshal(request, rq); err == nil {
				if bytes.Equal(rq.EncryptedDeviceToken, defaultKeeperContext.deviceToken) {
					err = NewKeeperApiError("exists", "public key already exists")
					return
				} else if bytes.Equal(rq.EncryptedDeviceToken, defaultKeeperContext.newDeviceToken) {
					if pe.NewDevice.publicKey == nil {
						pe.NewDevice.publicKey = rq.DevicePublicKey
					}
				}
				err = NewKeeperApiError("device_not_registered", "invalid device token")
				return
			}
		}
		break

	case "authentication/register_device":
		{
			rq := new(authentication.DeviceRegistrationRequest)
			if err = proto.Unmarshal(request, rq); err == nil {
				if pe.NewDevice.publicKey == nil {
					pe.NewDevice.publicKey = rq.DevicePublicKey
				}
				rs := new(authentication.Device)
				rs.EncryptedDeviceToken = defaultKeeperContext.newDeviceToken
				response, err = proto.Marshal(rs)
				return
			}
		}
		break

	case "authentication/start_login":
		{
			rq := new(authentication.StartLoginRequest)
			if err = proto.Unmarshal(request, rq); err == nil {
				var isNewDevice = false
				if bytes.Equal(rq.EncryptedDeviceToken, defaultKeeperContext.deviceToken) {
					isNewDevice = false
				} else if bytes.Equal(rq.EncryptedDeviceToken, defaultKeeperContext.newDeviceToken) && pe.NewDevice.publicKey != nil {
					isNewDevice = true
				} else {
					err = NewKeeperApiError("device_not_registered", "Device not registered")
					return
				}

				rs := new(authentication.LoginResponse)
				if rq.Username == "" && rq.EncryptedLoginToken == nil {
					if !isNewDevice {
						rs.PrimaryUsername = defaultKeeperContext.username
						rs.LoginState = authentication.LoginState_LOGGED_IN
						rs.SessionTokenType = authentication.SessionTokenType_NO_RESTRICTION
						rs.EncryptedSessionToken = defaultKeeperContext.sessionToken
						rs.EncryptedDataKeyType = authentication.EncryptedDataKeyType_BY_DEVICE_PUBLIC_KEY
						rs.EncryptedDataKey, _ = EncryptEc(defaultKeeperContext.dataKey, defaultKeeperContext.devicePublicKey)
					} else {
						rs.LoginState = authentication.LoginState_REQUIRES_USERNAME
					}
				} else if rq.Username == defaultKeeperContext.sso_username {
					rs.LoginState = authentication.LoginState_REDIRECT_CLOUD_SSO
					rs.EncryptedLoginToken = GetRandomBytes(64)
					rs.Url = "https://mock.keepersecurity.com/sso_login"
				} else if isNewDevice && !(pe.NewDevice.Approved && pe.NewDevice.TwoFactor) {
					rs.EncryptedLoginToken = GetRandomBytes(64)
					if !pe.NewDevice.Approved {
						rs.LoginState = authentication.LoginState_DEVICE_APPROVAL_REQUIRED
					} else if !pe.NewDevice.TwoFactor {
						rs.LoginState = authentication.LoginState_REQUIRES_2FA
						rs.Channels = append(rs.Channels, &authentication.TwoFactorChannelInfo{
							ChannelType: authentication.TwoFactorChannelType_TWO_FA_CT_SMS,
							ChannelUid:  GetRandomBytes(8),
							ChannelName: "Mock SMS",
							PhoneNumber: "1(555)555-5555",
						})
					}
				} else {
					rs.LoginState = authentication.LoginState_REQUIRES_AUTH_HASH
					rs.Salt = append(rs.Salt, &authentication.Salt{
						Iterations: defaultKeeperContext.authIterations,
						Salt:       defaultKeeperContext.authSalt,
						Algorithm:  0,
						Uid:        GetRandomBytes(8),
						Name:       "Master",
					})
				}
				response, err = proto.Marshal(rs)
				return
			}
		}
		break

	case "authentication/2fa_validate":
		{
			rq := new(authentication.TwoFactorValidateRequest)
			if err = proto.Unmarshal(request, rq); err == nil {
				if rq.Value == defaultKeeperContext.twoFactorCode {
					rs := &authentication.TwoFactorValidateResponse{}
					rs.EncryptedLoginToken = GetRandomBytes(64)
					response, err = proto.Marshal(rs)
					if !pe.NewDevice.Approved {
						pe.NewDevice.Approved = true
					} else if !pe.NewDevice.TwoFactor {
						pe.NewDevice.TwoFactor = true
					}
				} else {
					err = NewKeeperAuthFailed()
				}
			}
		}
		return
	case "authentication/2fa_send_push":
		{
			rq := new(authentication.TwoFactorSendPushRequest)
			if err = proto.Unmarshal(request, rq); err == nil {
				if !pe.NewDevice.Approved && rq.PushType == authentication.TwoFactorPushType_TWO_FA_PUSH_KEEPER {
					pe.NewDevice.Approved = true
					go func() {
						if pe.push != nil {
							time.Sleep(10 * time.Millisecond)
							var event = &NotificationEvent{
								Message:             "device_approved",
								EncryptedLoginToken: Base64UrlEncode(GetRandomBytes(64)),
								Approved:            true,
							}
							pe.push.Push(event)
						}
					}()
					return
				}
			}
		}
		break

	case "authentication/request_device_verification":
		{
			rq := new(authentication.DeviceVerificationRequest)
			if err = proto.Unmarshal(request, rq); err == nil {
				switch rq.VerificationChannel {
				case "email", "email_resend":
					pe.NewDevice.Approved = true
					go func() {
						if pe.push != nil {
							time.Sleep(10 * time.Millisecond)
							var event = &NotificationEvent{
								Command: "device_verified",
							}
							pe.push.Push(event)
						}
					}()
					break
				}
				return
			}
		}
		break
	case "authentication/validate_device_verification_code":
		{
			rq := new(authentication.ValidateDeviceVerificationCodeRequest)
			if err = proto.Unmarshal(request, rq); err == nil {
				if bytes.Equal(rq.EncryptedDeviceToken, defaultKeeperContext.deviceToken) {
					return
				} else if bytes.Equal(rq.EncryptedDeviceToken, defaultKeeperContext.newDeviceToken) {
					if rq.VerificationCode == defaultKeeperContext.twoFactorCode {
						pe.NewDevice.Approved = true
						return
					} else {
						err = NewKeeperAuthFailed()
					}
				} else {
					err = NewKeeperApiError("device_not_registered", "Invalid device token")
				}
			}
			return
		}
		break
	case "authentication/validate_auth_hash":
		{
			rq := new(authentication.ValidateAuthHashRequest)
			if err = proto.Unmarshal(request, rq); err == nil {
				rs := new(authentication.LoginResponse)
				switch rq.PasswordMethod {
				case authentication.PasswordMethod_ENTERED:
					{
						if bytes.Compare(rq.AuthResponse, defaultKeeperContext.authHash) == 0 {
							rs.PrimaryUsername = defaultKeeperContext.username
							rs.LoginState = authentication.LoginState_LOGGED_IN
							rs.SessionTokenType = authentication.SessionTokenType_NO_RESTRICTION
							rs.EncryptedSessionToken = defaultKeeperContext.sessionToken
							rs.EncryptedDataKeyType = authentication.EncryptedDataKeyType_BY_PASSWORD
							rs.EncryptedDataKey = defaultKeeperContext.encryptionParams

							response, err = proto.Marshal(rs)
							return
						}
					}
					break
				case authentication.PasswordMethod_BIOMETRICS:
					{
						rs.PrimaryUsername = defaultKeeperContext.username
						rs.LoginState = authentication.LoginState_LOGGED_IN
						rs.SessionTokenType = authentication.SessionTokenType_NO_RESTRICTION
						rs.EncryptedSessionToken = defaultKeeperContext.sessionToken
						rs.EncryptedDataKeyType = authentication.EncryptedDataKeyType_BY_BIO
						rs.EncryptedDataKey, err = EncryptAesV2(defaultKeeperContext.dataKey, defaultKeeperContext.biomerticKey)

						response, err = proto.Marshal(rs)
						return
					}
					break
				}
			}
		}
		err = NewKeeperAuthFailed()
		return

	case "login/account_summary":
		{
			rs := &account_summary.AccountSummaryElements{
				IsEnterpriseAdmin: false,
				KeysInfo: &account_summary.KeysInfo{
					EncryptedPrivateKey: defaultKeeperContext.encryptedPrivateKey,
				},
				Enforcements: &account_summary.Enforcements{},
				License:      &account_summary.License{},
				Settings:     &account_summary.Settings{},
			}
			rs.ClientKey, _ = EncryptAesV1(defaultKeeperContext.clientKey, defaultKeeperContext.dataKey)

			response, err = proto.Marshal(rs)
			return
		}
	}
	response = nil
	err = NewKeeperError("Keeper server Mock: unsupported endpoint: " + endpoint)
	return
}

type pushEndpointMock struct {
	isClosed bool
}

func (pe *pushEndpointMock) Close() {
	pe.isClosed = true
}

func (pe *pushEndpointMock) IsClosed() bool {
	return pe.isClosed
}

type authContextMock struct {
	license      *AccountLicense
	settings     *AccountSettings
	enforcements map[string]interface{}
}

func NewAuthContextMock() authentication2.IAuthContext {
	return new(authContextMock)
}
func (ac *authContextMock) Username() string {
	return defaultKeeperContext.username
}
func (ac *authContextMock) DeviceToken() []byte {
	return defaultKeeperContext.deviceToken
}
func (ac *authContextMock) DeviceKey() crypto.PrivateKey {
	return defaultKeeperContext.devicePrivateKey
}
func (ac *authContextMock) DataKey() []byte {
	return defaultKeeperContext.dataKey
}
func (ac *authContextMock) SessionToken() []byte {
	return defaultKeeperContext.sessionToken
}
func (ac *authContextMock) SessionRestriction() authentication2.SessionRestriction {
	return 0
}
func (ac *authContextMock) ClientKey() []byte {
	return defaultKeeperContext.clientKey
}
func (ac *authContextMock) RsaPrivateKey() crypto.PrivateKey {
	return defaultKeeperContext.rsaPrivateKey
}
func (ac *authContextMock) EcPrivateKey() crypto.PrivateKey {
	return nil
}
func (ac *authContextMock) IsEnterpriseAdmin() bool {
	return false
}
func (ac *authContextMock) License() *AccountLicense {
	if ac.license == nil {
		ac.license = &AccountLicense{}
	}
	return ac.license
}
func (ac *authContextMock) Settings() *AccountSettings {
	if ac.settings != nil {
		ac.settings = &AccountSettings{}
	}
	return ac.settings
}
func (ac *authContextMock) Enforcements() map[string]interface{} {
	if ac.enforcements != nil {
		ac.enforcements = make(map[string]interface{})
	}
	return ac.enforcements
}
func (ac *authContextMock) AccountAuthType() authentication2.AuthType {
	return authentication2.AuthType_Regular
}
func (ac *authContextMock) SsoLoginInfo() authentication2.ISsoLoginInfo {
	return nil
}
func (ac *authContextMock) CheckPasswordValid(password string) bool {
	return password == defaultKeeperContext.password
}
